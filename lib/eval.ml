
(*****************************************************************************)
(*                                                                           *)
(*                           Evaluation and Quoting                          *)
(*                                                                           *)
(*****************************************************************************)

open Base
    
open Term
open Value
open Suite
open Syntax

open Opetopes.Complex
open Opetopes.Idt

(*****************************************************************************)
(*                         Evaluation Utilities                              *)
(*****************************************************************************)

exception Eval_error of string

let ext_loc loc v i =
  if (i <= 0) then v
  else loc (i-1)

let emp_loc _ =
  raise (Eval_error "Empty local environment")

(*****************************************************************************)
(*                                Eliminators                                *)
(*****************************************************************************)

let rec appV t u =
  match t with
  | RigidV (i,sp) -> RigidV (i,AppSp(sp,u))
  | TopV (nm,sp,tv) -> TopV (nm,AppSp(sp,u), appV tv u)
  | LamV (_,cl) -> cl u
  | _ -> raise (Eval_error (Fmt.str "malformed application: %a" pp_value t))

let rec app_to_fib v_lst ty =
  match v_lst with
  | [] -> ty
  | v::vs -> app_to_fib vs (appV ty v)

(* TODO: Combine the next two functions? *)
let rec app_vars t v i =
  match t with
  | Emp -> (v,i)
  | Ext (t',(_,_)) ->
    let (v',k) = app_vars t' v i in 
    (appV v' (varV k), k + 1)

let rec fstV t =
  match t with
  | RigidV (i,sp) -> RigidV (i, FstSp sp)
  | TopV (nm,sp,tv) -> TopV (nm, FstSp sp, fstV tv)
  | PairV (u,_) -> u
  | _ -> raise (Eval_error (Fmt.str "malformed first proj: %a" pp_value t))

let rec sndV t =
  match t with
  | RigidV (i,sp) -> RigidV (i, SndSp sp)
  | TopV (nm,sp,tv) -> TopV (nm, SndSp sp, sndV tv)
  | PairV (_,v) -> v
  | _ -> raise (Eval_error (Fmt.str "malformed second proj: %a" pp_value t))

(*****************************************************************************)
(*                            Complex Combinators                            *)
(*****************************************************************************)

let fstC (c : value dep_term cmplx) : value dep_term cmplx
  = map_cmplx c
    ~f:(fun (vs,vo) -> (vs,Option.map vo ~f:fstV))

let sndC (c : value dep_term cmplx) (v : value) : value dep_term cmplx
  = map_cmplx c
    ~f:(fun (vs,vo) ->
        match vo with
        | None -> (Ext (vs,v),None)
        | Some p -> (Ext (vs,fstV p),Some (sndV p)))

(* This one is debateable.  Probably we should rather 
   adjoin the argument to the dep_term as a separate step ...*)
let appC (c : value dep_term cmplx) (arg_c : value cmplx) = 
  match_cmplx (face_cmplx arg_c) c
    ~f:(fun f (ss,so) ->
        let args = labels f in
        let top_arg = base_value (head_of f) in
        (Ext (ss,top_arg), Option.map so ~f:(app_to_fib args)))

(* Abstract over all the positions in a given complex and pass
   the abstracted values in complex form to the function b. *)
let rec lamC (a : 'a cmplx) (b : value cmplx -> value) : value =

  let rec do_lams nl cm =
    match nl with
    | [] -> b cm
    | addr::addrs ->
      LamV ("", fun v -> 
          do_lams addrs (replace_at cm (0,addr) v))

  in match a with
  | Base n ->
    let n' = map_nst_with_addr n
        ~f:(fun _ addr -> addr) in
    let nv = map_nst n ~f:(fun _ -> TypV) in 
    do_lams (nodes_nst n') (Base nv)
  | Adjoin (t,n) ->
    let n' = map_nst_with_addr n
        ~f:(fun _ addr -> addr) in 
    let nv = map_nst n ~f:(fun _ -> TypV) in 
    lamC t (fun vc -> do_lams (nodes_nst n') (Adjoin (vc,nv)))

(* Given the fibration a and a collection of cell values for the 
   telescopes, return the value cmplx whose cells are decorated 
   by the cell fibrations generated by a *)
let rec cellC (tl : value tele) (a : value) (args : value suite cmplx) : value cmplx =

  match args with
  | Base n ->

    let n' = map_nst n ~f:(fun vs -> app_to_fib (to_list vs) a) 
    in Base n'

  | Adjoin (t,n) ->

    let t' = cellC tl a t in

    let n' = map_nst_with_addr n
        ~f:(fun _ addr ->
            let f = face_at args (0,addr) in
            let f_tl = tail_of f in 
            let cell_fib = lamC f_tl (fun vc ->
                let dtc = match_cmplx vc f_tl
                    ~f:(fun v vs -> (vs,Some v)) in
                let hd = map_nst (head_of f)
                    ~f:(fun vs -> (vs,None)) in 
                CellV (tl,a, Adjoin (dtc,hd))) in
            cell_fib) in 

    Adjoin (t',n')


(* Abstract a list of types, putting the abstracted 
   value at the appropriate address in the provided complex *)
      
let rec do_pis nl cm b =
  match nl with
  | [] -> b cm
  | (addr,typ)::ns ->
    PiV ("", typ, fun v ->
        do_pis ns (replace_at cm (0,addr) v) b)

(* Given a "complex dependent type", extract the space 
   of sections of it with respect to the complex indexed 
   fibration b *)
let rec piC (a : value cmplx) (b : value cmplx -> value) : value =
  
  match a with
  | Base n ->

    let n' = map_nst_with_addr n
        ~f:(fun typ addr -> (addr,typ)) in
    do_pis (nodes_nst n') a b

  | Adjoin (t,n) ->

    piC t (fun vc ->

        let n' = map_nst_with_addr n
            ~f:(fun fib addr ->
                let f = face_at (Adjoin (vc,n)) (0,addr) in
                let f_tl = tail_of f in
                let typ = app_to_fib (labels f_tl) fib in 
                (addr,typ)) in

        do_pis (nodes_nst n') (Adjoin (vc,n)) b

      )

(* b takes just the frame, leaving out the top cell ... *)
let piKanC (addr : addr) (a : value cmplx) (b : value cmplx -> value) : value =
  
  match a with
  | Base _ -> failwith "Base in Kan abstraction"
  | Adjoin (Base k , _) ->

    let k' = map_nst_with_addr k
        ~f:(fun typ addr -> (addr,typ)) in
    do_pis (nodes_nst_except k' addr) (Base k) b

  | Adjoin (Adjoin (t,k),_) ->

    piC t (fun vc ->

        let k' = map_nst_with_addr k
            ~f:(fun fib addr ->
                let f = face_at (Adjoin (vc,k)) (0,addr) in
                let f_tl = tail_of f in
                let typ = app_to_fib (labels f_tl) fib in 
                (addr,typ)) in

        do_pis (nodes_nst_except k' addr)
          (Adjoin (vc,k)) b

      )
  
(*****************************************************************************)
(*                           Fibration Inspection                            *)
(*****************************************************************************)

type fib_desc =
  | SigFib of name * value * value
  | PiFib of name * value * value
  | TypFib
  | NeutralFib

let rec map_fib t v f =
  match t with
  | [] -> f v 
  | (nm,_)::tps ->
    LamV (nm,fun x ->
        let tps' = List.map tps ~f:(fun (nm,y) -> (nm,appV y x)) in
        let v' = appV v x in 
        map_fib tps' v' f)

let rec describe_fib tl ty =
  log_msg "in describe_fib";
  log_val "tl (df)" tl (pp_tele pp_value);
  (* Okay.  This is a bug.  We must be capturing here somehow ...*)
  match app_vars tl ty 50 with 
  | (SigV (nm,_,_),_) ->

    log_msg "found a sigma";
    log_val "tl (sig)" tl (pp_tele pp_value);
    let tlst = to_list tl in
    let a = map_fib tlst ty
        (function
          | SigV (_,a,_) -> a
          | _ -> failwith "ext_sig_src") in 

    let b = map_fib tlst ty
        (function
          | SigV (nm,_,b) -> LamV (nm,b)
          | _ -> failwith "ext_sig_tgt") in

    SigFib (nm,a,b)

  | (PiV (nm,_,_),_) ->

    let tlst = to_list tl in
    let a = map_fib tlst ty
        (function
          | PiV (_,a,_) -> a
          | _ -> failwith "ext_pi_src") in 

    let b = map_fib tlst ty
        (function
          | PiV (nm,_,b) -> LamV (nm,b)
          | _ -> failwith "ext_pi_tgt") in

    PiFib (nm,a,b)

  | (TypV,_) -> TypFib
    
  (* TODO: This won't quite work to unfold top-levels
     since the routines just after the recursive call will *also*
     hit a top-level and need to unfold it.  So they have to be
     corrected *)
  | (TopV (_,_,tv),_) ->
    describe_fib Emp tv

  | _ -> NeutralFib

(*****************************************************************************)
(*                           Cell Type Calculation                           *)
(*****************************************************************************)

let rec cellV tl ty c =
  log_msg "in cellV";
  log_val "tl" tl (pp_tele pp_value);
  (* log_val "ty" (quote true 0 ty) pp_term;  *)
  log_val "ty" ty pp_value; 
  log_val "c" c (pp_cmplx (pp_dep_term pp_value));
  match c with
  | Base (Lf (vs,_)) ->
    app_to_fib (to_list vs) ty 
  | _ ->

    begin match describe_fib tl ty with

      | SigFib (nm,a,b) ->

        log_val "a" (quote true 0 a) pp_term;
        let src_typ = cellV tl a (fstC c) in
        let tgt_typ x = cellV (Ext (tl,(nm,a))) b (sndC c x)

        in SigV ("",src_typ,tgt_typ)

      | PiFib (nm,a,b) -> 

        let a_cell = cellC tl a (map_cmplx c ~f:fst) in
        piC a_cell (fun args ->
            cellV (Ext (tl, (nm, a))) b (appC c args))

      | TypFib ->
        
        let c_dim = dim_cmplx c in
        let c_tl = tail_of c in
        
        let frm_fibs = map_cmplx_with_addr c_tl 
            ~f:(fun (_,vo) (codim,_) ->
                if (codim = c_dim - 1) then
                  Option.value_exn vo
                else
                  fstV (Option.value_exn vo)
              ) in

        let comp_fib = base_value (head_of frm_fibs) in

        (* These fibrations have to appear in reverse order *)
        
        (* 
         * FILLU - uniqueness of the filling cell 
         *)
        
        let fillu_typ fill_fib comp_op fill_op compu_op =

          let all_fibs = Adjoin (frm_fibs, Lf fill_fib) in

          piC all_fibs (fun arg_c ->

              let f = face_at arg_c (1,[]) in
              let cmp_args =
                begin match f with
                  | Base n -> nodes_nst_except n []
                  | Adjoin (t,n) ->
                    List.append (labels t)
                      (nodes_nst_except n []) 
                end in
              
              let cmp_typ = app_to_fib cmp_args comp_fib in

              
              let op_args =
                begin match arg_c with
                  | Base _ -> failwith "impossible"
                  | Adjoin (Base n,_) ->
                    nodes_nst_except n [] 
                  | Adjoin (Adjoin(t,k),_) ->
                    List.append (labels t) (nodes_nst_except k [])
                end in
              
              let fil_typ = app_to_fib op_args fill_fib in

              let po_cmplx = arr_cmplx
                  (Ext (Emp, app_to_fib op_args comp_op), Some (app_to_fib op_args fill_op))
                  (Ext (Emp, base_value (head_of f)), Some (base_value (head_of arg_c)))
                  (Ext (Emp, app_to_fib (labels arg_c) compu_op), None) 
              in 

              CellV (Ext (Emp,("",cmp_typ)),fil_typ,po_cmplx)) in 

        (*
         * COMPU - composite uniqueness
         *)
        
        let compu_typ fill_fib comp_op fill_op = 
          
          let all_fibs = Adjoin (frm_fibs, Lf fill_fib) in

          let p = piC all_fibs (fun arg_c ->
              
              let f = face_at arg_c (1,[]) in
              let cmp_args =
                begin match f with
                  | Base n -> nodes_nst_except n []
                  | Adjoin (t,n) ->
                    List.append (labels t)
                      (nodes_nst_except n []) 
                end in
              
              let cmp_typ = app_to_fib cmp_args comp_fib in

              let op_args =
                begin match arg_c with
                  | Base _ -> failwith "impossible"
                  | Adjoin (Base n,_) ->
                    nodes_nst_except n [] 
                  | Adjoin (Adjoin(t,k),_) ->
                    List.append (labels t) (nodes_nst_except k [])
                end in 
              
              let eq_cell = arr_cmplx
                (Emp, Some (app_to_fib op_args comp_op))
                (Emp, Some (base_value (head_of f)))
                (Emp, None) 
              in 
              
              CellV (Emp,cmp_typ,eq_cell)

            )

          in SigV ("", p, fillu_typ fill_fib comp_op fill_op) 

        in 

        (*
         *  FILL - the filling cell
         *)
        
        let fill_typ fill_fib comp_op =

          let p = piKanC [] (Adjoin (frm_fibs, Lf fill_fib))
            (fun kc ->

               let comp_args =
                 begin match kc with
                   | Base n -> nodes_nst_except n []
                   | Adjoin (t,n) ->
                     List.append (labels t)
                       (nodes_nst_except n []) 
                 end in

               let kc' = replace_at kc (0,[])
                   (app_to_fib comp_args comp_op) in

               app_to_fib (labels kc') fill_fib

            ) in

          SigV ("", p, compu_typ fill_fib comp_op)
          
        in

        (*
         *  COMP - the composite cell 
         *)
        
        let comp_typ fill_fib =
          let all_fibs = Adjoin (frm_fibs, Lf fill_fib) in
          let p = piKanC [] all_fibs
              (fun kc ->

                 if (c_dim = 1) then
                   comp_fib
                 else
                   let f_args = face_at kc (0,[]) in
                   app_to_fib (labels (tail_of f_args)) comp_fib

              ) in

          SigV ("", p, fill_typ fill_fib)
          
        in
        
        SigV ("", piC frm_fibs (fun _ -> TypV), comp_typ)
                
      | _ -> CellV (tl,ty,c)

    end

(*****************************************************************************)
(*                                 Evaluation                                *)
(*****************************************************************************)

and eval top loc tm =
  (* pr "Evaluating: %a@," pp_term tm; *)
  match tm with
  | VarT i -> loc i 
  | TopT nm -> TopV (nm,EmpSp,top nm)

  | LamT (nm,u) ->
    LamV (nm,fun v -> eval top (ext_loc loc v) u)
  | AppT (u,v) -> appV (eval top loc u) (eval top loc v) 
  | PiT (nm,a,b) ->
    PiV (nm, eval top loc a,
         fun v -> eval top (ext_loc loc v) b)

  | PairT (u,v) ->
    PairV (eval top loc u, eval top loc v)
  | FstT u ->
    fstV (eval top loc u)
  | SndT u ->
    sndV (eval top loc u)
  | SigT (nm,u,v) ->
    SigV (nm, eval top loc u,
          fun x -> eval top (ext_loc loc x) v)

  | CellT (tl,ty,c) ->
    let (tl_v, ty_v, c_v) =
      eval_cell_desc top loc tl ty c in
    cellV tl_v ty_v c_v
  | CompT (tl,ty,c) ->
    let (tl_v, ty_v, c_v) =
      eval_cell_desc top loc tl ty c in
    CompV  (tl_v , ty_v , c_v)
  | FillT (tl,ty,c) ->
    let (tl_v, ty_v, c_v) =
      eval_cell_desc top loc tl ty c in
    FillV  (tl_v , ty_v , c_v)
  | CompUT (tl,ty,k,c,f) ->
    let (tl_v, ty_v, c_v) =
      eval_cell_desc top loc tl ty k in
    CompUV  (tl_v , ty_v , c_v ,
             eval top loc c,
             eval top loc f)
  | FillUT (tl,ty,k,c,f) ->
    let (tl_v, ty_v, c_v) =
      eval_cell_desc top loc tl ty k in
    FillUV  (tl_v , ty_v , c_v ,
             eval top loc c,
             eval top loc f)


  | TypT -> TypV

and eval_cell_desc top loc tl ty c =
  let (tl_v , ty_v) = eval_fib top loc tl ty in 
  let c_v = map_cell_desc_cmplx c ~f:(eval top loc) in 
  (tl_v, ty_v, c_v)

and eval_fib top loc tl ty =
  match tl with
  | Emp -> (Emp , eval top loc ty)
  | Ext (tl',(nm,ty')) ->

    let (tl_v , ty_v) = eval_fib top loc tl' ty' in
    let lams = TermUtil.abstract_tele tl ty in 
    let this_ty_val = eval top loc lams in

    (Ext (tl_v,(nm,ty_v)) , this_ty_val) 


(*****************************************************************************)
(*                                  Quoting                                  *)
(*****************************************************************************)

and quote ufld k v =
  let qc x = quote ufld k x in
  let qcs x s = quote_sp ufld k x s in
  match v with
  | RigidV (l,sp) -> qcs (VarT (lvl_to_idx k l)) sp
  | TopV (_,_,tv) when ufld -> qc tv
  | TopV (nm,sp,_) -> qcs (TopT nm) sp

  | LamV (nm,cl) -> LamT (nm, quote ufld (k+1) (cl (varV k)))
  | PiV (nm,u,cl) -> PiT (nm, qc u, quote ufld (k+1) (cl (varV k)))

  | PairV (u,v) -> PairT (qc u, qc v)
  | SigV (nm,u,cl) -> SigT (nm, qc u, quote ufld (k+1) (cl (varV k)))

  | CellV (tl,ty,c) ->
    let (tl',ty',c') = quote_cell_desc ufld k tl ty c in
    CellT (tl',ty',c')
  | CompV (tl,ty,c) ->
    let (tl',ty',c') = quote_cell_desc ufld k tl ty c in
    CompT (tl',ty',c')
  | FillV (tl,ty,c) ->
    let (tl',ty',c') = quote_cell_desc ufld k tl ty c in
    FillT (tl',ty',c')
  | CompUV (tl,ty,kn,c,f) ->
    let (tl',ty',kn') = quote_cell_desc ufld k tl ty kn in
    CompUT (tl',ty',kn',qc c,qc f)
  | FillUV (tl,ty,kn,c,f) ->
    let (tl',ty',kn') = quote_cell_desc ufld k tl ty kn in
    FillUT (tl',ty',kn',qc c,qc f)

  | TypV -> TypT

and quote_cell_desc ufld k tl ty c = 
  let (tl',ty') = quote_fib ufld k tl ty in
  let c' = map_cell_desc_cmplx c ~f:(quote ufld k)in
  (tl',ty',c')

and quote_fib ufld k tl ty =
  match tl with
  | Emp -> (Emp , quote ufld k ty)
  | Ext (tl',(nm,ty')) ->

    let (tl_tm, ty_tm) = quote_fib ufld k tl' ty' in
    let (app_v , k') = app_vars tl ty k in

    (Ext (tl_tm,(nm,ty_tm)) , quote ufld k' app_v)

and quote_sp ufld k t sp =
  let qc x = quote ufld k x in
  let qcs x s = quote_sp ufld k x s in
  match sp with
  | EmpSp -> t
  | AppSp (sp',u) ->
    AppT (qcs t sp',qc u)
  | FstSp sp' ->
    FstT (qcs t sp')
  | SndSp sp' ->
    SndT (qcs t sp') 


