#
#  Playing with some ideas
#

let Eq (A : U) (a₀ : A) (a₁ : A) : U
  = [ ⊢ A
    | nd { ⊢ a₁ } (nd (lf { ⊢ a₀ }) (lf tt)) 
    | lf { ⊢ ● }
    ] 

let PathOver
    (A : U) (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (B : A → U) (b₀ : B a₀) (b₁ : B a₁) : U
  = [ (a : A) ⊢ B a
    | nd { a₁ ⊢ b₁ } (nd (lf { a₀ ⊢ b₀ }) (lf tt)) 
    | lf { p ⊢ ● }
    ] 

#
#  Some configurations of types in the telescope
#

let type-in-ctx (A : U) (B : U) (E : Eq U A B)
    (a : A) (b : B) : U
  = [ (T : U) ⊢ T
    | nd { B ⊢ b } (nd (lf { A ⊢ a }) (lf tt)) 
    | lf { E ⊢ ● }
    ]

let sig-in-ctx (M : U) (α : M → M)
    (N : U) (β : N → N) (m : M) (n : N) 
    (I : Eq ((A : U) × (A → A)) (N , β) (M , α)) : U
  = [ (E : (A : U) × (A → A)) ⊢ fst E 
    | nd { (M , α) ⊢ m } (nd (lf { (N , β) ⊢ n }) (lf tt)) 
    | lf { I ⊢ ● }
    ]

let pi-in-ctx (A : U)
    (B : A → U) (C : A → U)
    (E : Eq (A → U) B C)
    (a₀ : A) (a₁ : A) (c : C a₁) (b : B a₀)
    (p : PathOver (A → U) B C E (λ σ . A) a₀ a₁) : U
  = [ (σ : A → U) (a : A) ⊢ σ a 
    | nd { C ; a₁ ⊢ c } (nd (lf { B ; a₀ ⊢ b }) (lf tt)) 
    | lf { E ; p ⊢ ● }
    ]

# Right, and what happens here?  This is what I was worried about: the
# path "p" doesn't have the right type to be able to feed it to the
# equivalence E.  For that, it should be a "real" path in A.

# But in any case, what we are supposed to do here is apply the equality
# of functions E to a path in A, resulting in a path in the universe,
# and then a path over here between c and b is just an element of the
# resulting relation.

# Yikes.  But this looks pretty ad-hoc.  Because the A could just be
# on the other side, in which case, this would work fine.

# Another thing which could be weird is that there could be type
# "below" σ, so that E is in fact some kind of path-over instead of a
# real path.  Ah, I see, but in that case, it's kind of still okay,
# since it will still be a function type, just with a more complicated
# domain.


#  What about the case when the variable is bound outside the telescope?
let pi-in-ctx-cst (A : U)
    (B : A → U) (C : A → U)
    (E : Eq (A → U) B C)
    (a₀ : A) (c : C a₀) (b : B a₀) : U
  = [ (σ : A → U) ⊢ σ a₀
    | nd { C ⊢ c } (nd (lf { B  ⊢ b }) (lf tt)) 
    | lf { E ⊢ ● }
    ]

# So in this case, we will need to expand the term, probably using our
# dependent ap, to be the correct shape and then apply it to our E.
