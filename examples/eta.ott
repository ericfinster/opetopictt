#
#  eta.ott - testing eta-long forms 
#

normalize (A : U) (B : A â†’ U)
    (Ïƒ : (a : A) â†’ B a)
  : (a : A) â†’ B a 
  | Ïƒ

normalize (A : U) (B : A â†’ U)
    (C : (a : A) â†’ B a â†’ U)
    (Ïƒ : (a : A) â†’ (b : B a) â†’ C a b)
  : (a : A) â†’ (b : B a) â†’ C a b
  | Ïƒ

# uh, yeah.  so here, since we don't
# name the variable in the pi abstraction
# we don't have a name to expand with.
normalize (A : U) (B : U)
    (f : (A â†’ A) â†’ B)
  : (A â†’ A) â†’ B 
  | f 

# this is the correct version of the above...
normalize (A : U) (B : U)
    (f : (q : (a : A) â†’ A) â†’ B)
  : (q : (a : A) â†’ A) â†’ B
  | f 

#
#  Trying for positions ...
#

normalize (P : Pos) (Q : El P â†’ U)
    (Ïƒ : (p : P) â†’â‚š Q p)
  : (p : P) â†’â‚š Q p
  | Ïƒ

normalize (u : El âŠ¤â‚š)
  : El âŠ¤â‚š
  | u

# this shows how now all dependent types over the unit position type
# are now constant....
normalize (A : El âŠ¤â‚š â†’ U)
  : El âŠ¤â‚š â†’ U 
  | A

normalize (A : El âŠ¥â‚š â†’ U) (Ïƒ : (b : âŠ¥â‚š) â†’â‚š A b)
  : (b : âŠ¥â‚š) â†’â‚š A b 
  | Ïƒ 

normalize (P : Pos) (Q : Pos) (A : El (P âŠ”â‚š Q) â†’ U)
    (Ïƒ : (pq : P âŠ”â‚š Q) â†’â‚š A pq)
  : (pq : P âŠ”â‚š Q) â†’â‚š A pq
  | Ïƒ 

normalize (P : Pos) (Q : Pos) (A : El (P âŠ”â‚š Q) â†’ U)
    (l : (p : P) â†’â‚š A (inlâ‚š p))
    (r : (q : Q) â†’â‚š A (inrâ‚š q))
  : (pq : P âŠ”â‚š Q) â†’â‚š A pq
  | âŠ”-elim l r 

# So is this kind of positive Î·-rule enough to get us commutation of
# functions through the sum eliminator?  Where would I have an example
# of that? 

# Here's what Antoine needed:

# âŠ”â‚š-Frm-rec-lem : âˆ€ {â„“} {n : â„•} {X Y : ğ•† â„“ n}
#     â†’ {U V : â„™}
#     â†’ (inlâ‚š* : El U â†’ Frm X)
#     â†’ (inrâ‚š* : El V â†’ Frm X)
#     â†’ (g : Frm X â†’ Frm Y)
#     â†’ g âˆ˜ (âŠ”â‚š-Frm-rec inlâ‚š* inrâ‚š*) == âŠ”â‚š-Frm-rec (g âˆ˜ inlâ‚š*) (g âˆ˜ inrâ‚š*)
# âŠ”â‚š-Frm-rec-lem {U = U} {V} inlâ‚š* inrâ‚š* g =
#   let P p = g (âŠ”â‚š-Frm-rec inlâ‚š* inrâ‚š* p) == âŠ”â‚š-Frm-rec (g âˆ˜ inlâ‚š*) (g âˆ˜ inrâ‚š*) p
#   in Î»= (âŠ”â‚š-elim {U = U} {V} P (Î» _ â†’ idp) (Î» _ â†’ idp))

# here's the thing to test, then:
# normalize (P : Pos) (Q : Pos)
#     (A : El (P âŠ”â‚š Q) â†’ U)
#     (B : El (P âŠ”â‚š Q) â†’ U)
#     (l : (p : P) â†’â‚š A (inlâ‚š p))
#     (r : (q : Q) â†’â‚š A (inrâ‚š q))
#     (g : (pq : El (P âŠ”â‚š Q)) â†’ A pq â†’ B pq)
#   : (pq : P âŠ”â‚š Q) â†’â‚š B pq
#   | Î»â‚š pq . g pq ((âŠ”-elim l r) @ pq)
  
  # the alternative is this:
  # | âŠ”â‚š-elim (Î»â‚š p . g (inlâ‚š p) (l p))
  #           (Î»â‚š q . g (inrâ‚š q) (r q)) 

# so there are some typing problems because we are not inferring
# eliminators but checking them.  But other than that, it indeed
# looks like this is exactly the kind of equation that we will
# get from the strong Î·-rule for sums.
