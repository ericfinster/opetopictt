#
#  Testing new composition setup
#

#
#  Basic Shapes 
#

let Eq (A : U) (aâ‚€ : A) (aâ‚ : A) : U
  = [ âŠ¢ A
    | nd { âŠ¢ aâ‚ } (nd (lf { âŠ¢ aâ‚€ }) (lf tt)) 
    | lf { âŠ¢ â— }
    ] 

let Null (A : U) (a : A) (p : Eq A a a) : U
  = [ âŠ¢ A
    | lf { âŠ¢ a }
    | nd { âŠ¢ p } (lf tt)
    | lf { âŠ¢ â— }
    ] 

let PathOver
    (A : U) (aâ‚€ : A) (aâ‚ : A) (p : Eq A aâ‚€ aâ‚)
    (B : A â†’ U) (bâ‚€ : B aâ‚€) (bâ‚ : B aâ‚) : U
  = [ (a : A) âŠ¢ B a
    | nd { aâ‚ âŠ¢ bâ‚ } (nd (lf { aâ‚€ âŠ¢ bâ‚€ }) (lf tt)) 
    | lf { p âŠ¢ â— }
    ] 


let Simplex
    (A : U) (aâ‚€ : A) (aâ‚ : A) (aâ‚‚ : A)
    (p : Eq A aâ‚€ aâ‚) (q : Eq A aâ‚ aâ‚‚) (r : Eq A aâ‚€ aâ‚‚) : U
  = [ âŠ¢ A
    | nd { âŠ¢ aâ‚‚ } (nd (nd { âŠ¢ aâ‚ } (nd (lf { âŠ¢ aâ‚€ }) (lf tt))) (lf tt))
    | nd { âŠ¢ r } (nd (lf { âŠ¢ q }) (nd (nd (lf { âŠ¢ p })
        (nd (lf tt) (lf tt))) (lf tt)))
    | lf { âŠ¢ â— }
    ]

let transport (A : U) (B : A â†’ U)
    (aâ‚€ : A) (aâ‚ : A) (p : Eq A aâ‚€ aâ‚)
    (bâ‚€ : B aâ‚€) : B aâ‚ 
  = comp [ (a : A) âŠ¢ B a
         | nd { aâ‚ âŠ¢ â— } (nd (lf { aâ‚€ âŠ¢ bâ‚€ }) (lf tt)) 
         | lf { p âŠ¢ â— }
         ]

#
#  Refl, Null and their Uniqueness
#

let refl (A : U) (a : A) : Eq A a a
  = comp [ âŠ¢ A
         | lf { âŠ¢ a }
         | nd { âŠ¢ â— } (lf tt)
         | lf { âŠ¢ â— }
         ]

let null (A : U) (a : A) : Null A a (refl A a)
  = fill [ âŠ¢ A
         | lf { âŠ¢ a }
         | nd { âŠ¢ â— } (lf tt)
         | lf { âŠ¢ â— }
         ]

let reflU (A : U) (a : A) (p : Eq A a a) (n : Null A a p)
  : Eq (Eq A a a) (refl A a) p
  = compu
    [ âŠ¢ A
    | lf { âŠ¢ a }
    | nd { âŠ¢ â— } (lf tt)
    | lf { âŠ¢ â— }
    ] p n

let nullU (A : U) (a : A) (p : Eq A a a) (n : Null A a p)
  : PathOver (Eq A a a) (refl A a) p (reflU A a p n)
             (Null A a) (null A a) n
  = fillu 
    [ âŠ¢ A
    | lf { âŠ¢ a }
    | nd { âŠ¢ â— } (lf tt)
    | lf { âŠ¢ â— }
    ] p n

#
#  Opetopic J for Refl and Null
#

let refl-J (A : U) (a : A)
    (P : (p : Eq A a a) â†’ (n : Null A a p) â†’ U)
    (d : P (refl A a) (null A a))
    (p : Eq A a a) (n : Null A a p) 
  : P p n
  = comp [ (x : Eq A a a) (y : Null A a x) âŠ¢ P x y
         | nd { p ; n âŠ¢ â— } (nd (lf { refl A a ; null A a âŠ¢ d }) (lf tt)) 
         | lf { reflU A a p n ; nullU A a p n âŠ¢ â— }
         ]


#
#  Singletons and J 
#

let singleton (A : U) (aâ‚€ : A) : U
  = (aâ‚ : A) Ã— Eq A aâ‚€ aâ‚ 

let ucomp (A : U) (a : A) : A
  = comp [ âŠ¢ A
         | nd { âŠ¢ â— } (nd (lf { âŠ¢ a }) (lf tt)) 
         | lf { âŠ¢ â— }
         ] 

let ufill (A : U) (a : A) : Eq A a (ucomp A a)
  = fill [ âŠ¢ A
         | nd { âŠ¢ â— } (nd (lf { âŠ¢ a }) (lf tt)) 
         | lf { âŠ¢ â— }
         ]

let ucomp-unique (A : U) (a : A) (s : singleton A a)
  : Eq A (ucomp A a) (fst s) 
  = compu [ âŠ¢ A
          | nd { âŠ¢ â— } (nd (lf { âŠ¢ a }) (lf tt)) 
          | lf { âŠ¢ â— }
          ] (fst s) (snd s) 

let ufill-unique (A : U) (a : A) (s : singleton A a) 
  : PathOver A (ucomp A a) (fst s) (ucomp-unique A a s)
             (Eq A a) (ufill A a) (snd s) 
  = fillu [ âŠ¢ A
          | nd { âŠ¢ â— } (nd (lf { âŠ¢ a }) (lf tt)) 
          | lf { âŠ¢ â— }
          ] (fst s) (snd s) 

let singleton-to (A : U) (a : A) (s : singleton A a)
  : Eq (singleton A a) (ucomp A a , ufill A a) s 
  = (ucomp-unique A a s , ufill-unique A a s)

let arrow-J (A : U) (aâ‚€ : A)
    (P : (aâ‚ : A) â†’ (p : Eq A aâ‚€ aâ‚) â†’ U)
    (d : P (ucomp A aâ‚€) (ufill A aâ‚€))
    (aâ‚ : A) (p : Eq A aâ‚€ aâ‚)
  : P aâ‚ p
  = comp [ (x : A) (y : Eq A aâ‚€ x) âŠ¢ P x y
         | nd { aâ‚ ; p âŠ¢ â— } (nd (lf { ucomp A aâ‚€ ; ufill A aâ‚€ âŠ¢ d }) (lf tt)) 
         | lf { ucomp-unique A aâ‚€ (aâ‚ , p) ; ufill-unique A aâ‚€ (aâ‚ , p) âŠ¢ â— }
         ]

let singleton-from (A : U) (a : A) (s : singleton A a)
  : Eq (singleton A a) s (ucomp A a , ufill A a) 
  = arrow-J A a (Î» aâ‚ . Î» p . Eq (singleton A a) (aâ‚ , p) (ucomp A a , ufill A a))
    (refl (singleton A a) (ucomp A a , ufill A a)) (fst s) (snd s) 


# let J (A : U) (aâ‚€ : A) (P : out_path A aâ‚€ â†’ U)
#     (d : P (aâ‚€ , refl A aâ‚€)) (aâ‚ : A) (p : Eq A aâ‚€ aâ‚)
#   : P (aâ‚ , p)
#   = transport (out_path A aâ‚€) P
#       (aâ‚€ , refl A aâ‚€) (aâ‚ , p) (path_from_refl A aâ‚€ aâ‚ p) d

#
#  Testing Cell reduction for Î£
#

let Î£-test (A : U) (B : A â†’ U) 
    (aâ‚€ : A) (bâ‚€ : B aâ‚€)
    (aâ‚ : A) (bâ‚ : B aâ‚)
    (p : Eq A aâ‚€ aâ‚) (q : PathOver A aâ‚€ aâ‚ p B bâ‚€ bâ‚)
  : Eq ((a : A) Ã— B a) (aâ‚€ , bâ‚€) (aâ‚ , bâ‚)
  = p , q 

#
#  Testing Cell reduction for Î 
#

# Interesting to see that the order of abstraction here is
# really crucial.  This isn't officially a bug, but you
# should revisit how it comes out for ergonomics ...

let Î -test (A : U) (B : A -> U)
    (Ïƒâ‚€ : (a : A) â†’ B a)
    (Ïƒâ‚ : (a : A) â†’ B a)
    (Ïƒâ‚€â‚ : (aâ‚€ : A) â†’ (aâ‚ : A) â†’ (aâ‚€â‚ : Eq A aâ‚€ aâ‚)
      â†’ PathOver A aâ‚€ aâ‚ aâ‚€â‚ B (Ïƒâ‚€ aâ‚€) (Ïƒâ‚ aâ‚))
  : Eq ((a : A) â†’ B a) Ïƒâ‚€ Ïƒâ‚
  = Ïƒâ‚€â‚


#
#  Testing Cell reduction for ğ•Œ 
#

let Univ-test (A : U) (B : U)
    (E : A â†’ B â†’ U)
    # (B-comp : B â†’ A)
    # (B-fill : (b : B) â†’ E b (B-comp b))
    (A-comp : A â†’ B)
    (A-fill : (a : A) â†’ E a (A-comp a))
    (A-compu : (a : A) â†’ (b : B) â†’ (p : E a b)
      â†’ Eq B (A-comp a) b)
    (A-fillu : (a : A) â†’ (b : B) â†’ (p : E a b)
      â†’ PathOver B (A-comp a) b (A-compu a b p)
          (E a) (A-fill a) p)
  : Eq U A B
  = (E , A-comp, A-fill, A-compu, A-fillu)


let Univ-test2 (A : U) (B : U) (C : U)
    (E : Eq U A B)
    (F : Eq U B C)
    (G : Eq U A C)
    (H : (a : A) â†’ (b : B) â†’ (c : C)
      â†’ (e : (fst E) a b)
      â†’ (f : (fst F) b c)
      â†’ (g : (fst G) a c) â†’ U)
    (H-comp : (a : A) â†’ (b : B) â†’ (c : C)
      â†’ (e : (fst E) a b)
      â†’ (f : (fst F) b c)
      â†’ (fst G) a c)
    (H-fill : (a : A) â†’ (b : B) â†’ (c : C)
      â†’ (e : (fst E) a b)
      â†’ (f : (fst F) b c)
      â†’ H a b c e f (H-comp a b c e f))
    (H-compu : (a : A) â†’ (b : B) â†’ (c : C)
      â†’ (e : (fst E) a b)
      â†’ (f : (fst F) b c)
      â†’ (g : (fst G) a c)
      â†’ (h : H a b c e f g)
      â†’ Eq ((fst G) a c) (H-comp a b c e f) g)
    (H-fillu : (a : A) â†’ (b : B) â†’ (c : C)
      â†’ (e : (fst E) a b)
      â†’ (f : (fst F) b c)
      â†’ (g : (fst G) a c)
      â†’ (h : H a b c e f g)
      â†’ PathOver ((fst G) a c) (H-comp a b c e f) g
          (H-compu a b c e f g h)
          (H a b c e f) (H-fill a b c e f) h)
  : Simplex U A B C E F G
  = (H, H-comp, H-fill, H-compu, H-fillu)

# let id (A : U) : A â†’ A
#   = Î» a . a

# normalize (A : U) (a : A) : A 
#   | id A a 

# normalize (A : U) (B : U)
#     (E : Eq U A B) (F : Eq U A B) : U 
#   | Eq (Eq U A B) E F 

# # Equality is refl in the universe
# let Univ-refl (A : U) : Eq U A A
#   = (Eq A , (id A , refl A) , (id A , refl A))

# # And it's null homotopy is null!
# let Univ-null (A : U) : Null U A (Univ-refl A)
#   = (Null A , (refl A , null A))

