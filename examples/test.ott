#
#  test.ott - testing out our new capabilities
#

let Eq (A : U) (a₀ : A) (a₁ : A) : U
  = fst [ A
        @ nd { y } (nd (lf { x }) (lf tt)) 
        | lf { p }
        ] a₀ a₁

let refl (A : U) (a : A) : Eq A a a
  = [ a
    @ nd { y } (nd (lf { x }) (lf tt)) 
    | lf { p }
    ]

let PathOver (A : U) (B : A → U)
    (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (b₀ : B a₀) (b₁ : B a₁) : U
  = fst ([ B
         @ nd { y } (nd (lf { x }) (lf tt)) 
         | lf { p }
         ] a₀ a₁ p) b₀ b₁

let transport (A : U) (B : A → U)
    (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (b₀ : B a₀) : B a₁
  = fst snd ([ B
             @ nd { y } (nd (lf { x }) (lf tt)) 
             | lf { p }
             ] a₀ a₁ p) b₀

let Σ-eq (A : U) (B : A → U)
    (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (b₀ : B a₀) (b₁ : B a₁) (q : PathOver A B a₀ a₁ p b₀ b₁)
  : Eq ((a : A) × B a) (a₀ , b₀) (a₁ , b₁)
  = p , q 

# normalize (A : U) (a₀ : A) (a₁ : A) : U
#   ⊢ Eq A a₀ a₁ 

# normalize (A : U) (B : A → U)
#     (σ₀ : (a : A) → B a)
#     (σ₁ : (a : A) → B a) : U
#   ⊢ fst [ (a : A) → B a 
#         @ nd { y } (nd (lf { x }) (lf tt)) 
#         | lf { p }
#         ] σ₀ σ₁

# normalize (A : U) (B : A → U)
#     (σ₀ : (a : A) → B a)
#     (σ₁ : (a : A) → B a) : U
#   ⊢ Eq ((a : A) → B a) σ₀ σ₁

# normalize (A : U) (B : A → U)
#     (a₀ : A) (a₁ : A) 
#     (b₀ : B a₀) (b₁ : B a₁) : U
#   ⊢ Eq ((a : A) × B a) (a₀ , b₀) (a₁ , b₁) 

#
#  Some other shapes ....
#

let Square (A : U) (a₀₀ : A) (a₀₁ : A)
    (a₁₀ : A) (a₁₁ : A)
    (p : Eq A a₀₀ a₀₁) (q : Eq A a₁₀ a₁₁)
    (r : Eq A a₀₀ a₁₀) (s : Eq A a₀₁ a₁₁) : U
  = fst ([ Eq A
         @ nd { y } (nd (lf { x }) (lf tt)) 
         | lf { p }
         ] a₀₀ a₀₁ p a₁₀ a₁₁ q) r s 




