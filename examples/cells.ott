#
#  cells.ott - demonstrations of cells
#

let Eq (A : U) (a₀ : A) (a₁ : A) : U
  = [ ⊢ A
    | nd { ⊢ a₁ } (nd (lf { ⊢ a₀ }) (lf tt)) 
    | lf { ⊢ ● }
    ] 

let PathOver
    (A : U) (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (B : A → U) (b₀ : B a₀) (b₁ : B a₁) : U
  = [ (a : A) ⊢ B a
    | nd { a₁ ⊢ b₁ } (nd (lf { a₀ ⊢ b₀ }) (lf tt)) 
    | lf { p ⊢ ● }
    ] 

let PathOverOver
    (A : U) (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (B : A → U) (b₀ : B a₀) (b₁ : B a₁) (q : PathOver A a₀ a₁ p B b₀ b₁)
    (C : (a : A) → (b : B a) → U) (c₀ : C a₀ b₀) (c₁ : C a₁ b₁) : U
  = [ (a : A) (b : B a) ⊢ C a b
    | nd { a₁ ; b₁ ⊢ c₁ } (nd (lf { a₀ ; b₀ ⊢ c₀ }) (lf tt)) 
    | lf { p ; q ⊢ ● }
    ] 

let Null (A : U) (a : A) (p : Eq A a a) : U
  = [ ⊢ A
    | lf { ⊢ a }
    | nd { ⊢ p } (lf tt)
    | lf { ⊢ ● }
    ] 

let Simplex
    (A : U) (a₀ : A) (a₁ : A) (a₂ : A)
    (p : Eq A a₀ a₁) (q : Eq A a₁ a₂) (r : Eq A a₀ a₂) : U
  = [ ⊢ A
    | nd { ⊢ a₂ } (nd (nd { ⊢ a₁ } (nd (lf { ⊢ a₀ }) (lf tt))) (lf tt))
    | nd { ⊢ r } (nd (lf { ⊢ q }) (nd (nd (lf { ⊢ p })
        (nd (lf tt) (lf tt))) (lf tt)))
    | lf { ⊢ ● }
    ]

let SimplexOver
    (A : U) (a₀ : A) (a₁ : A) (a₂ : A)
    (pa : Eq A a₀ a₁) (qa : Eq A a₁ a₂) (ra : Eq A a₀ a₂)
    (σ : Simplex A a₀ a₁ a₂ pa qa ra)
    (B : A → U) (b₀ : B a₀) (b₁ : B a₁) (b₂ : B a₂)
    (pb : PathOver A a₀ a₁ pa B b₀ b₁)
    (qb : PathOver A a₁ a₂ qa B b₁ b₂)
    (rb : PathOver A a₀ a₂ ra B b₀ b₂) : U
  = [ (a : A) ⊢ B a
    | nd { a₂ ⊢ b₂ } (nd (nd { a₁ ⊢ b₁ } (nd (lf { a₀ ⊢ b₀ }) (lf tt))) (lf tt))
    | nd { ra ⊢ rb } (nd (lf { qa ⊢ qb }) (nd (nd (lf { pa ⊢ pb })
        (nd (lf tt) (lf tt))) (lf tt)))
    | lf { σ ⊢ ● }
    ]

# This example shows how constant fibrations do not calculate quite as
# nicely as one might hope in the current setting ...

let Square
    (A : U) (a₀₀ : A) (a₀₁ : A) (a₁₀ : A) (a₁₁ : A)
    (p : Eq A a₀₀ a₀₁)
    (q : Eq A a₀₀ a₁₀)
    (s : Eq A a₁₀ a₁₁)
    (r : PathOver A a₀₀ a₁₀ q (λ a . A) a₀₁ a₁₁) : U
    # Would have liked: (r : Eq A a₀₁ a₁₁)
  = [ (a₀ : A) (a₁ : A) ⊢ Eq A a₀ a₁
    | nd { a₁₀ ; a₁₁ ⊢ s } (nd (lf { a₀₀ ; a₀₁ ⊢ p }) (lf tt)) 
    | lf { q ; r ⊢ ● }
    ] 


#
#  Various comp tests 
#

let transport (A : U) (B : A → U)
    (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
    (b₀ : B a₀) : B a₁ 
  = comp [ (a : A) ⊢ B a
         | nd { a₁ ⊢ ● } (nd (lf { a₀ ⊢ b₀ }) (lf tt)) 
         | lf { p ⊢ ● }
         ]

let transport-univ (A : U) (B : U) (e : Eq U A B) (a : A) : B 
  = comp [ (T : U) ⊢ T
         | nd { B ⊢ ● } (nd (lf { A ⊢ a }) (lf tt)) 
         | lf { e ⊢ ● }
         ]


let var-cells (A : U) (B : U) (e : Eq U A B)
    (a : A) (b : B) : U 
  = [ (T : U) ⊢ T
    | nd { B ⊢ b } (nd (lf { A ⊢ a }) (lf tt)) 
    | lf { e ⊢ ● }
    ]

let refl (A : U) (a : A) : Eq A a a
  = comp [ ⊢ A
         | lf { ⊢ a }
         | nd { ⊢ ● } (lf tt)
         | lf { ⊢ ● }
         ]

let null (A : U) (a : A) : Null A a (refl A a)
  = fill [ ⊢ A
         | lf { ⊢ a }
         | nd { ⊢ ● } (lf tt)
         | lf { ⊢ ● }
         ]

let refl-over (A : U) (B : A → U) (a : A) (b : B a)
  : PathOver A a a (refl A a) B b b
  = comp [ (a : A) ⊢ B a
         | lf { a ⊢ b }
         | nd { refl A a ⊢ ● } (lf tt)
         | lf { null A a ⊢ ● }
         ]

let trans (A : U) (a₀ : A) (a₁ : A) (a₂ : A)
    (p : Eq A a₀ a₁) (q : Eq A a₁ a₂) : Eq A a₀ a₂
  = comp [ ⊢ A
         | nd { ⊢ a₂ } (nd (nd { ⊢ a₁ } (nd (lf { ⊢ a₀ }) (lf tt))) (lf tt))
         | nd { ⊢ ● } (nd (lf { ⊢ q }) (nd (nd (lf { ⊢ p })
             (nd (lf tt) (lf tt))) (lf tt)))
         | lf { ⊢ ● }
         ]

let sym (A : U) (a₀ : A) (a₁ : A)
    (p : Eq A a₀ a₁) : Eq A a₁ a₀
  = comp [ ⊢ A
         | nd { ⊢ a₀ } (nd (nd { ⊢ a₁ } (nd (lf { ⊢ a₀ }) (lf tt))) (lf tt))
         | nd { ⊢ refl A a₀ } (nd (lf { ⊢ ● }) (nd (nd (lf { ⊢ p })
             (nd (lf tt) (lf tt))) (lf tt)))
         | lf { ⊢ ● }
         ]



#
#  Testing the kan eliminator
#

let ucomp (A : U) (a : A) : A
  = comp [ ⊢ A
         | nd { ⊢ ● } (nd (lf { ⊢ a }) (lf tt)) 
         | lf { ⊢ ● }
         ] 

let ufill (A : U) (a : A) : Eq A a (ucomp A a)
  = fill [ ⊢ A
         | nd { ⊢ ● } (nd (lf { ⊢ a }) (lf tt)) 
         | lf { ⊢ ● }
         ]

let out_path (A : U) (a₀ : A) : U
  = (a₁ : A) × (Eq A a₀ a₁)

let out_path_contr (A : U) (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁) 
  : Eq (out_path A a₀) (a₁ , p) (ucomp A a₀ , ufill A a₀)
  = kan-elim [ ⊢ A
             | nd { ⊢ ● } (nd (lf { ⊢ a₀ }) (lf tt)) 
             | lf { ⊢ ● }
             ]

    (λ c. λ f. Eq (out_path A a₀) (c , f) (ucomp A a₀ , ufill A a₀))
    (refl (out_path A a₀) (ucomp A a₀ , ufill A a₀)) a₁ p

let out_path_from (A : U) (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁) 
  : Eq (out_path A a₀) (ucomp A a₀ , ufill A a₀) (a₁ , p) 
  = kan-elim [ ⊢ A
             | nd { ⊢ ● } (nd (lf { ⊢ a₀ }) (lf tt)) 
             | lf { ⊢ ● }
             ]

    (λ c. λ f. Eq (out_path A a₀) (ucomp A a₀ , ufill A a₀) (c , f))
    (refl (out_path A a₀) (ucomp A a₀ , ufill A a₀)) a₁ p

let path_from_refl (A : U) (a₀ : A) (a₁ : A) (p : Eq A a₀ a₁)
  : Eq (out_path A a₀) (a₀ , refl A a₀) (a₁ , p)
  = trans (out_path A a₀) (a₀ , refl A a₀) (ucomp A a₀ , ufill A a₀) (a₁ , p)
      (out_path_contr A a₀ a₀ (refl A a₀))
      (out_path_from A a₀ a₁ p)

let J (A : U) (a₀ : A) (P : out_path A a₀ → U)
    (d : P (a₀ , refl A a₀)) (a₁ : A) (p : Eq A a₀ a₁)
  : P (a₁ , p)
  = transport (out_path A a₀) P
      (a₀ , refl A a₀) (a₁ , p) (path_from_refl A a₀ a₁ p) d

#
#  Testing Cell reduction for Σ
#

let Σ-test (A : U) (B : A → U) 
    (a₀ : A) (b₀ : B a₀)
    (a₁ : A) (b₁ : B a₁)
    (p : Eq A a₀ a₁) (q : PathOver A a₀ a₁ p B b₀ b₁)
  : Eq ((a : A) × B a) (a₀ , b₀) (a₁ , b₁)
  = p , q 

#
#  Testing Cell reduction for Π
#

# Interesting to see that the order of abstraction here is
# really crucial.  This isn't officially a bug, but you
# should revisit how it comes out for ergonomics ...

let Π-test (A : U) (B : A -> U)
    (σ₀ : (a : A) → B a)
    (σ₁ : (a : A) → B a)
    (σ₀₁ : (a₁ : A) → (a₀ : A) → (a₀₁ : Eq A a₀ a₁)
      → PathOver A a₀ a₁ a₀₁ B (σ₀ a₀) (σ₁ a₁))
  : Eq ((a : A) → B a) σ₀ σ₁
  = σ₀₁

#
#  Testing cell reduction for U
#

let Univ-test (A : U) (B : U)
    (E : B → A → U)
    (B-comp : B → A)
    (B-fill : (b : B) → E b (B-comp b))
    (B-elim : (b : B) → (P : (a : A) → E b a → U)
      → (d : P (B-comp b) (B-fill b))
      → (a : A) → (e : E b a) → P a e)
    (A-comp : A → B)
    (A-fill : (a : A) → E (A-comp a) a)
    (A-elim : (a : A) → (P : (b : B) → E b a → U)
      → (d : P (A-comp a) (A-fill a))
      → (b : B) → (e : E b a) → P b e)
  : Eq U A B
  = (E , (A-comp , A-fill) , (B-comp , B-fill))

let Univ-test2 (A : U) (B : U) (C : U)
    (E : Eq U A B)
    (F : Eq U B C)
    (G : Eq U A C)
    (H : (c : C) → (b : B) → (a : A)
      → (g : (fst G) c a)
      → (f : (fst F) c b)
      → (e : (fst E) b a) → U)
    (G-comp : (c : C) → (b : B) → (a : A)
      → (f : (fst F) c b)
      → (e : (fst E) b a)
      → (fst G) c a)
    (G-fill : (c : C) → (b : B) → (a : A)
      → (f : (fst F) c b)
      → (e : (fst E) b a)
      → H c b a (G-comp c b a f e) f e)
    (F-comp : (c : C) → (b : B) → (a : A)
      → (g : (fst G) c a)
      → (e : (fst E) b a)
      → (fst F) c b)
    (F-fill : (c : C) → (b : B) → (a : A)
      → (g : (fst G) c a)
      → (e : (fst E) b a)
      → H c b a g (F-comp c b a g e) e)
    (E-comp : (c : C) → (b : B) → (a : A)
      → (g : (fst G) c a)
      → (f : (fst F) c b)
      → (fst E) b a)
    (E-fill : (c : C) → (b : B) → (a : A)
      → (g : (fst G) c a)
      → (f : (fst F) c b)
      → H c b a g f (E-comp c b a g f))
  : Simplex U A B C E F G
  = (H, (G-comp, G-fill), (F-comp, F-fill) , (E-comp, E-fill))


let id (A : U) : A → A
  = λ a . a

# Equality is refl in the universe
let Univ-refl (A : U) : Eq U A A
  = (Eq A , (id A , refl A) , (id A , refl A))

# And it's null homotopy is null!
let Univ-null (A : U) : Null U A (Univ-refl A)
  = (Null A , (refl A , null A))

let pi-refl-test (A : U) (B : A → U) (σ : (a : A) → B a)
  : (a₁ : A) → (a₀ : A)
     → (p : Eq A a₀ a₁)
     → PathOver A a₀ a₁ p B (σ a₀) (σ a₁)
  = refl ((a : A) → B a) σ

let pi-refl-def (A : U) (B : A → U)
    (σ : (a : A) → B a) (a₀ : A) 
    (a₁ : A) (p : Eq A a₀ a₁)
  : PathOver A a₀ a₁ p B (σ a₀) (σ a₁)
  = J A a₀ (λ op . PathOver A a₀ (fst op) (snd op) B (σ a₀) (σ (fst op)))
    (refl-over A B a₀ (σ a₀)) a₁ p 

